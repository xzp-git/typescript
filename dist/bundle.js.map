{"version":3,"file":"bundle.js","sources":["../src/index.ts"],"sourcesContent":["/**\r\n * interface 描述对象的形状和结构,可以给数据增添类型 而且方便复用\r\n * \r\n * type 的方式 通过别名来重新定义类型\r\n * \r\n * interface 可以被类实现 和继承  type没有这个功能\r\n * type 可以使用联合类型,interface 不能使用联合类型\r\n */\r\n\r\nlet school = {\r\n  name: 'foo',\r\n  age: 24\r\n}\r\ntype schools = Array<typeof school>;\r\nfunction aa(school: schools) {\r\n}\r\naa([{ name: 'foo', age: 24 }]);\r\n\r\n// 1) 如何用接口描述对象类型, 如果有联合类型 就使用type\r\n\r\n// interface IObj{\r\n//   name:string\r\n//   age:number\r\n// }\r\n\r\ntype IObj = { name: string, age: number } | string\r\n\r\nconst getObj = (obj: IObj) => { }\r\ngetObj({ name: 'foo', age: 24 })\r\ngetObj('aaaa')\r\n\r\n// 2)描述函数类型\r\ninterface ISum {\r\n  (a: string, b: string): string\r\n}\r\n\r\n// type ISum = (a:string, b:string) => string\r\n\r\nconst sum: ISum = (a, b) => {\r\n  return a + b\r\n}\r\n\r\n// 3)计数器的例子  每次调用函数就累加1\r\n\r\ninterface ICount { //接口中的混合类型\r\n  (): number\r\n  count: number\r\n}\r\n\r\nconst fn: ICount = (() => {\r\n  return ++fn.count\r\n}) as ICount\r\nfn.count = 0;\r\nconsole.log(fn());\r\nconsole.log(fn());\r\nconsole.log(fn());\r\n\r\ninterface IEffect {\r\n  (): void\r\n  id: number\r\n}\r\nfunction effect(fn: Function) {\r\n    const reactiveEffect = createReactiveEffect(fn);\r\n    return reactiveEffect\r\n}\r\n\r\nfunction createReactiveEffect(fn: Function) {\r\n  const effect: IEffect = function reactiveEffect() {\r\n\r\n  }\r\n  effect.id = 1;\r\n  return effect\r\n}\r\n"],"names":[],"mappings":";;;EAiDA,IAAM,EAAE,IAAY;MAClB,OAAO,EAAE,EAAE,CAAC,KAAK,CAAA;EACnB,CAAC,CAAW,CAAA;EACZ,EAAE,CAAC,KAAK,GAAG,CAAC,CAAC;EACb,OAAO,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;EAClB,OAAO,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;EAClB,OAAO,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC;;;;;;"}