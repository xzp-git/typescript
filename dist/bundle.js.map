{"version":3,"file":"bundle.js","sources":["../src/index.ts"],"sourcesContent":["//泛型的用处在于 当我们调用的时候 确定类型 而不是一开始就写好类型，类型不确定，只有在执行的时候才能确定\r\n\r\n//1.单个泛型 声明的时候 需要用 <> 包裹起来 传值的时候也需要\r\n\r\n// function createArray<T>(times:number, value:T):T[] {\r\n//   let result = []\r\n//   for(let i = 0; i < times; i++){\r\n//     result.push(value)\r\n//   }\r\n//   return result\r\n// }\r\n// let r = createArray(5,'aav')\r\n\r\ninterface IMyArr<T>{\r\n  [key:number]:T\r\n}\r\n\r\ninterface ICreateArray<K>{\r\n  //interface后面的 类型和函数前面的类型的区别，如果放在函数前面 表示使用函数的时候确定了类型放在接口的后面表示时使用接口的时候确定类型\r\n  <T>(x:K, y:T):IMyArr<T>\r\n}\r\n\r\nconst createArray:ICreateArray<number> = (times,value) => {\r\n  let result = []\r\n  for(let i = 0; i < times; i++){\r\n    result.push(value)\r\n  }\r\n  return result\r\n}\r\ncreateArray(3, 'aaa')\r\n\r\n//2. 多个泛型 元组进行类型交换\r\n\r\nconst swap = <T, K>(tuple: [T, K]):[K, T] => {\r\n  return [tuple[1], tuple[0]]\r\n}\r\n\r\nlet r = swap([123, 'sss00'])\r\n\r\n//约束对象\r\n const sum = <T extends string>(a: T, b: T):T => {\r\n   return (a + b ) as T\r\n }\r\n sum('a', 'v')\r\n\r\n //3. 泛型约束 主要强调类型中必须包含某个属性\r\n type withLen = {length: number}\r\n const computeArrayLength = <T extends withLen, K extends withLen>(arr1:T, arr2:K):number => {\r\n   return arr1.length + arr2.length\r\n }\r\n\r\n computeArrayLength('123', {length:3})\r\n\r\n const getVal = <T extends object, K extends keyof T>(obj: T, key: K) => {\r\n   if (typeof obj !== 'object') {\r\n     return \r\n   }\r\n   return obj[key]\r\n }\r\n\r\n type T1 = keyof{a:1, b:2}\r\n type T2 = keyof string\r\n type T3 = keyof any //string | number | symbol\r\n\r\n getVal({a:1}, 'a')\r\n\r\n//泛型可以给类来使用\r\n\r\nclass GetArrayMax<T = number>{\r\n  public arr:T[] = []\r\n  add(val:T){\r\n    this.arr.push(val)\r\n  }\r\n  getMax():T{\r\n    let arr = this.arr\r\n    let max = arr[0];\r\n    for (let i = 1; i < arr.length; i++) {\r\n        arr[i] > max ? max = arr[i] : null\r\n    }\r\n    return max;\r\n  }\r\n}\r\nlet arr = new GetArrayMax(); // 泛型只有当使用后才知道具体的类型\r\narr.add(1);\r\narr.add(2)\r\narr.add(3)\r\nlet r1 = arr.getMax()\r\n\r\n// 泛型可以在 函数 类 （接口、别名） 中使用 \r\n\r\n// extends 约束  keyof 取当前类型的key  typeof 取当前值的类型\r\n\r\nexport { }"],"names":[],"mappings":";;;EAAA;EA+BA;EAEA,IAAM,IAAI,GAAG,UAAO,KAAa;MAC/B,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAA;EAC7B,CAAC,CAAA;EAEO,IAAI,CAAC,CAAC,GAAG,EAAE,OAAO,CAAC,EAAC;EAU3B,IAAM,kBAAkB,GAAG,UAAuC,IAAM,EAAE,IAAM;MAC9E,OAAO,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAA;EAClC,CAAC,CAAA;EAED,kBAAkB,CAAC,KAAK,EAAE,EAAC,MAAM,EAAC,CAAC,EAAC,CAAC,CAAA;EAErC,IAAM,MAAM,GAAG,UAAsC,GAAM,EAAE,GAAM;MACjE,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;UAC3B,OAAM;OACP;MACD,OAAO,GAAG,CAAC,GAAG,CAAC,CAAA;EACjB,CAAC,CAAA;EAMD,MAAM,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,GAAG,CAAC,CAAA;EAEnB;EAEA;MAAA;UACS,QAAG,GAAO,EAAE,CAAA;OAYpB;MAXC,yBAAG,GAAH,UAAI,GAAK;UACP,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;OACnB;MACD,4BAAM,GAAN;UACE,IAAI,GAAG,GAAG,IAAI,CAAC,GAAG,CAAA;UAClB,IAAI,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;UACjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;cACjC,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAA;WACrC;UACD,OAAO,GAAG,CAAC;OACZ;MACH,kBAAC;EAAD,CAAC,IAAA;EACD,IAAI,GAAG,GAAG,IAAI,WAAW,EAAE,CAAC;EAC5B,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EACX,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAA;EACV,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAA;EACD,GAAG,CAAC,MAAM;;;;;;"}